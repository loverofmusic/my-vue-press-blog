(window.webpackJsonp=window.webpackJsonp||[]).push([[86],{457:function(v,_,t){"use strict";t.r(_);var l=t(5),n=Object(l.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h3",{attrs:{id:"作用域与执行上下文"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#作用域与执行上下文"}},[v._v("#")]),v._v(" 作用域与执行上下文")]),v._v(" "),t("p",[v._v("许多开发人员经常混淆作用域和执行上下文的概念，误认为它们是相同的概念，但事实并非如此。")]),v._v(" "),t("p",[v._v("我们知道 JavaScript 属于解释型语言，JavaScript 的执行分为：解释和执行两个阶段,这两个阶段所做的事并不一样：")]),v._v(" "),t("ol",[t("li",[v._v("解释阶段：\n"),t("ul",[t("li",[v._v("词法分析")]),v._v(" "),t("li",[v._v("语法分析")]),v._v(" "),t("li",[v._v("作用域规则确定")])])]),v._v(" "),t("li",[v._v("执行阶段：\n"),t("ul",[t("li",[v._v("创建执行上下文")]),v._v(" "),t("li",[v._v("执行函数代码")]),v._v(" "),t("li",[v._v("垃圾回收")])])])]),v._v(" "),t("p",[v._v("JavaScript "),t("strong",[v._v("解释编译阶段")]),v._v("便会确定作用域规则，因此作用域在"),t("strong",[v._v("函数定义时")]),v._v("就已经确定了，而不是在"),t("strong",[v._v("函数调用时")]),v._v("确定，")]),v._v(" "),t("p",[v._v("但是执行上下文是调用时，函数体代码执行之前创建的。函数调用结束，上下文环境就被释放。\n执行上下文最明显的就是 this 的指向是执行时确定的。而作用域访问的变量是编写代码的结构确定的。")]),v._v(" "),t("p",[v._v("作用域和执行上下文之间最大的区别是：\n执行上下文在运行时确定，随时可能改变；作用域在定义时就确定，并且不会改变。")]),v._v(" "),t("p",[v._v("一个作用域下可能包含若干个上下文环境。有可能从来没有过上下文环境（函数从来就没有被调用过）；有可能有过，现在函数被调用完毕后，上下文环境被销毁了；有可能同时存在一个或多个（闭包）。同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值。")])])}),[],!1,null,null,null);_.default=n.exports}}]);