(window.webpackJsonp=window.webpackJsonp||[]).push([[81],{451:function(v,e,t){"use strict";t.r(e);var a=t(5),_=Object(a.a)({},(function(){var v=this,e=v.$createElement,t=v._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h2",{attrs:{id:"vue源码解析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue源码解析"}},[v._v("#")]),v._v(" Vue源码解析")]),v._v(" "),t("h3",{attrs:{id:"_1-手写-vue-的-mvvm-响应式原代码（简单版）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-手写-vue-的-mvvm-响应式原代码（简单版）"}},[v._v("#")]),v._v(" 1.手写 Vue 的 MVVM 响应式原代码（简单版）")]),v._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",[v._v("采用数据劫持结合发布者-订阅者的方式，通过Object.defineProperty()来劫持各个属性的setter、getter，在数据变动时，发布消息给订阅者，触发相应的监听回调。")])]),v._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://github.com/loverofmusic/Vue-MVVM-demo.git",target:"_blank",rel:"noopener noreferrer"}},[v._v("GitHub demo链接"),t("OutboundLink")],1)]),v._v(" "),t("li",[t("img",{attrs:{src:"/my-vue-press-blog/img/interview/mvvm.jpg",alt:"mvvm"}})]),v._v(" "),t("li",[v._v("主要实现过程：\n"),t("ul",[t("li",[v._v("入口函数的实现")]),v._v(" "),t("li",[v._v("编译类 Compile 的实现")]),v._v(" "),t("li",[v._v("实现 Observer 劫持并监听所有属性")]),v._v(" "),t("li",[v._v("实现观察者 Watcher 和 依赖收集器 Dep")]),v._v(" "),t("li",[v._v("实现双向数据绑定和 Proxy 代理")])])]),v._v(" "),t("li",[v._v("参照源码：\n"),t("ul",[t("li",[t("img",{attrs:{src:"/my-vue-press-blog/img/interview/mvvm2.jpg",alt:"mvvm2"}})])])])]),v._v(" "),t("h3",{attrs:{id:"vue-中是如何检测数组变化的？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue-中是如何检测数组变化的？"}},[v._v("#")]),v._v(" Vue 中是如何检测数组变化的？")]),v._v(" "),t("ul",[t("li",[v._v("使用函数劫持的方式，"),t("code",[v._v("重写了数组的原型方法")])]),v._v(" "),t("li",[v._v("将data中的数组，进行了原型链重写，指向了自己定义的数组原型方法，这样当调用数组API时，可以通知依赖更新，如果数组中包含引用类型，会对数组中的引用类型再次进行监控")])]),v._v(" "),t("p",[t("img",{attrs:{src:"/my-vue-press-blog/img/interview/vue-array.jpg",alt:"vue-array"}})]),v._v(" "),t("h3",{attrs:{id:"_6-vue-中computed的特点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-vue-中computed的特点"}},[v._v("#")]),v._v(" 6.Vue 中computed的特点")]),v._v(" "),t("h3",{attrs:{id:"_7-watch-中的-deep-true-是如何实现的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-watch-中的-deep-true-是如何实现的"}},[v._v("#")]),v._v(" 7.watch 中的 deep:true 是如何实现的")]),v._v(" "),t("h3",{attrs:{id:"_8-vue-组件的生命周期"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8-vue-组件的生命周期"}},[v._v("#")]),v._v(" 8.Vue 组件的生命周期")]),v._v(" "),t("h3",{attrs:{id:"_9-ajax-请求放在哪个生命周期中"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_9-ajax-请求放在哪个生命周期中"}},[v._v("#")]),v._v(" 9.ajax 请求放在哪个生命周期中")]),v._v(" "),t("h3",{attrs:{id:"_10-何时需要使用-beforedestroy"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_10-何时需要使用-beforedestroy"}},[v._v("#")]),v._v(" 10.何时需要使用 beforeDestroy")]),v._v(" "),t("ul",[t("li",[v._v("清除自己定义的"),t("code",[v._v("定时器")]),v._v(" setTimeout...")]),v._v(" "),t("li",[v._v("解除"),t("code",[v._v("事件绑定")]),v._v("：scroll mousemove....")]),v._v(" "),t("li",[v._v("当前页面中使用了"),t("code",[v._v("$on")]),v._v("方法 需要在组件销毁前解绑")])]),v._v(" "),t("h3",{attrs:{id:"_11-vue-中模板编译原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_11-vue-中模板编译原理"}},[v._v("#")]),v._v(" 11.Vue 中模板编译原理")]),v._v(" "),t("ul",[t("li",[v._v("讲 template 转化成 render 函数")])]),v._v(" "),t("h3",{attrs:{id:"_12-vue中-v-if-和-v-show-的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_12-vue中-v-if-和-v-show-的区别"}},[v._v("#")]),v._v(" 12.Vue中 v-if 和 v-show 的区别")]),v._v(" "),t("h3",{attrs:{id:"_13-为什么-v-for-和-v-if-不能连用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_13-为什么-v-for-和-v-if-不能连用"}},[v._v("#")]),v._v(" 13.为什么 v-for 和 v-if 不能连用")]),v._v(" "),t("ul",[t("li",[t("img",{attrs:{src:"/my-vue-press-blog/img/interview/vue-v-if.jpg",alt:"vue-v-if"}})]),v._v(" "),t("li",[v._v("v-for 会比 v-if 的"),t("code",[v._v("优先级")]),v._v("高一些，如果连用的话 会把 v-if 给每个元素都添加一下，会造成性能问题")])]),v._v(" "),t("h3",{attrs:{id:"_14-如何使用-vnode-描述-dom-节点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_14-如何使用-vnode-描述-dom-节点"}},[v._v("#")]),v._v(" 14.如何使用 vnode 描述 DOM 节点")]),v._v(" "),t("ul",[t("li",[t("img",{attrs:{src:"/my-vue-press-blog/img/interview/vue-vnode.jpg",alt:"vue-vnode"}})])]),v._v(" "),t("h3",{attrs:{id:"_15-diff-算法的时间复杂度"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_15-diff-算法的时间复杂度"}},[v._v("#")]),v._v(" 15.diff 算法的时间复杂度")]),v._v(" "),t("ul",[t("li",[v._v("两颗树的完全的 diff 算法是一个时间复杂度为 O(n3)，Vue 进行了优化变成O(n) (只比较同级不考虑跨级问题)，在前端中，很少会跨层级移动Dom元素，所以 Virtual Dom  只会对比同一层级的元素")])]),v._v(" "),t("h3",{attrs:{id:"_16-简述-vue-中-diff-算法原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_16-简述-vue-中-diff-算法原理"}},[v._v("#")]),v._v(" 16.简述 Vue 中 diff 算法原理")]),v._v(" "),t("ol",[t("li",[v._v("先比较同级，再比较子节点")]),v._v(" "),t("li",[v._v("先判断一方有儿子一方没儿子的情况")]),v._v(" "),t("li",[v._v("比较都有儿子的情况")]),v._v(" "),t("li",[v._v("递归比较子节点")])]),v._v(" "),t("ul",[t("li",[t("img",{attrs:{src:"/my-vue-press-blog/img/interview/vue-dom-diff0.jpg",alt:"vue-diff0"}})]),v._v(" "),t("li",[t("img",{attrs:{src:"/my-vue-press-blog/img/interview/vue-dom-diff1.jpg",alt:"vue-diff1"}})])]),v._v(" "),t("h3",{attrs:{id:"_17-v-for-中为什么要用-key"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_17-v-for-中为什么要用-key"}},[v._v("#")]),v._v(" 17.v-for 中为什么要用 key")]),v._v(" "),t("ul",[t("li",[t("img",{attrs:{src:"/my-vue-press-blog/img/interview/vue-key.jpg",alt:"vue-key"}})])]),v._v(" "),t("h3",{attrs:{id:"_18-描述组件渲染和更新过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_18-描述组件渲染和更新过程"}},[v._v("#")]),v._v(" 18.描述组件渲染和更新过程")]),v._v(" "),t("ul",[t("li",[v._v("渲染组件时， 会通过 Vue.extend 方法构建子组件的构造函数，并进行实例化。最终手动调用 $mount() 进行挂载。更新组件时，会进行 patchVnode流程，核心就是 diff 算法")]),v._v(" "),t("li",[t("img",{attrs:{src:"/my-vue-press-blog/img/interview/vue-component.jpg",alt:"vue-component"}})]),v._v(" "),t("li",[t("img",{attrs:{src:"/my-vue-press-blog/img/interview/vue-component1.jpg",alt:"vue-component"}})])]),v._v(" "),t("h3",{attrs:{id:"_19-组件中的-data-为什么是函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_19-组件中的-data-为什么是函数"}},[v._v("#")]),v._v(" 19.组件中的 data 为什么是函数")]),v._v(" "),t("ul",[t("li",[v._v("同一个"),t("code",[v._v("组件被复用")]),v._v("多次，会创建多个实例。这些实例用的是同一个构造函数，如果data是一个对象的话，那么所有实例都共享了同一个对象。为了保证组件复用时的数据独立性 要求每个组件必须通过data函数返回一个对象 作为组件状态")]),v._v(" "),t("li",[t("img",{attrs:{src:"/my-vue-press-blog/img/interview/vue-data0.jpg",alt:"vue-data0"}})]),v._v(" "),t("li",[t("img",{attrs:{src:"/my-vue-press-blog/img/interview/vue-data1.jpg",alt:"vue-data1"}})])]),v._v(" "),t("h3",{attrs:{id:"_20-vue-中事件绑定原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_20-vue-中事件绑定原理"}},[v._v("#")]),v._v(" 20.Vue 中事件绑定原理")]),v._v(" "),t("ul",[t("li",[v._v("原生dom事件绑定")]),v._v(" "),t("li",[v._v("组件事件绑定")])]),v._v(" "),t("h3",{attrs:{id:"_21-v-model中的实现原理及如何自定义v-model"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_21-v-model中的实现原理及如何自定义v-model"}},[v._v("#")]),v._v(" 21.v-model中的实现原理及如何自定义v-model")]),v._v(" "),t("ul",[t("li",[v._v("可以看成是value+input方法的语法糖")])]),v._v(" "),t("h3",{attrs:{id:"_22-vue-中-v-html-会导致哪些问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_22-vue-中-v-html-会导致哪些问题"}},[v._v("#")]),v._v(" 22.Vue 中 v-html 会导致哪些问题")]),v._v(" "),t("ul",[t("li",[v._v("可能导致xss攻击")]),v._v(" "),t("li",[v._v("会替换掉标签内部元素")])]),v._v(" "),t("h3",{attrs:{id:"_23"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_23"}},[v._v("#")]),v._v(" 23.")]),v._v(" "),t("h3",{attrs:{id:"_24-vue-中组件如何通信？单向数据流"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_24-vue-中组件如何通信？单向数据流"}},[v._v("#")]),v._v(" 24.Vue 中组件如何通信？单向数据流")]),v._v(" "),t("ul",[t("li",[v._v("父子间通信 父->子通过 props、子->父 $on $emit")]),v._v(" "),t("li",[v._v("获取父子组件实例的方式 $parent、$children")]),v._v(" "),t("li",[v._v("在父组件中提供数据 子组件进行消费 Provide、inject")]),v._v(" "),t("li",[v._v("Ref获取实例的方式调用组件的属性或者方法")]),v._v(" "),t("li",[v._v("Event Bus 实现跨组件通信")]),v._v(" "),t("li",[v._v("Vuex状态管理")])]),v._v(" "),t("h3",{attrs:{id:"_25-vue-中相同逻辑如何抽离？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_25-vue-中相同逻辑如何抽离？"}},[v._v("#")]),v._v(" 25. Vue 中相同逻辑如何抽离？")]),v._v(" "),t("ul",[t("li",[v._v("mixin")])]),v._v(" "),t("h3",{attrs:{id:"_26-为什么要使用异步组件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_26-为什么要使用异步组件"}},[v._v("#")]),v._v(" 26.为什么要使用异步组件")]),v._v(" "),t("ul",[t("li",[v._v("如果组件功能多打包出的结果会变大， 可以采用异步的方式，主要依赖import（）这个语法，可以实现文件的按需加载。")])]),v._v(" "),t("h3",{attrs:{id:"_27-什么是作用域插槽？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_27-什么是作用域插槽？"}},[v._v("#")]),v._v(" 27.什么是作用域插槽？")]),v._v(" "),t("ul",[t("li",[v._v("首先明确普通插槽，然后比较两者")]),v._v(" "),t("li",[v._v("作用域插槽：父组件替换插槽的标签，但是内容由子组件来提供；渲染的位置是子组件")]),v._v(" "),t("li",[v._v("普通插槽：渲染的位置是父组件")])]),v._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[v._v("slot插槽")]),v._v(" "),t("p",[v._v("为了让我们封装的组件更加具有扩展性（让使用者可以决定组件内部的一些内容到底展示什么，例如：移动网站中的导航栏）")])]),v._v(" "),t("h3",{attrs:{id:"_28-谈谈你对keep-alive的了解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_28-谈谈你对keep-alive的了解"}},[v._v("#")]),v._v(" 28.谈谈你对keep-alive的了解")]),v._v(" "),t("ul",[t("li",[v._v("实现 组件缓存，当组件切换时不会对当前组件进行卸载，常用的2个 属性 include、exclude；2个生命周期 activated、deactivated")])]),v._v(" "),t("h3",{attrs:{id:"_29-vue中常见性能优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_29-vue中常见性能优化"}},[v._v("#")]),v._v(" 29.Vue中常见性能优化")]),v._v(" "),t("ul",[t("li",[v._v("编码优化：\n"),t("ol",[t("li",[v._v("不要将所有数据都放在data中，data中的数据都会增加getter和setter，会收集对应的watcher")]),v._v(" "),t("li",[v._v("vue 在 v-for 时给每项元素绑定事件需要用事件代理")]),v._v(" "),t("li",[v._v("SPA 页面采用keep-alive缓存组件")]),v._v(" "),t("li",[v._v("拆分组件（提高复用性、增加代码的可维护性、减少不必要渲染）")]),v._v(" "),t("li",[v._v("v-if 当值为false时 内部指令不会执行，具有阻断功能，很多情况下可以使用其代替v-show")]),v._v(" "),t("li",[v._v("key 保证唯一性")]),v._v(" "),t("li",[v._v("Object.freeze冻结数据")]),v._v(" "),t("li",[v._v("合理使用路由懒加载、异步组件")]),v._v(" "),t("li",[v._v("尽量使用runtime运行时版本")]),v._v(" "),t("li",[v._v("数据持久化问题（防抖 节流）")])])]),v._v(" "),t("li",[v._v("加载性能优化\n"),t("ol",[t("li",[v._v("第三方模块按需导入（babel-plugin-component）")]),v._v(" "),t("li",[v._v("滚动到可视区域动态加载")]),v._v(" "),t("li",[v._v("图片懒加载")])])]),v._v(" "),t("li",[v._v("用户体验\n"),t("ol",[t("li",[v._v("app-skeleton骨架屏")]),v._v(" "),t("li",[v._v("app-shell app壳")])])])]),v._v(" "),t("h3",{attrs:{id:"为何vue采用异步渲染？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为何vue采用异步渲染？"}},[v._v("#")]),v._v(" 为何Vue采用异步渲染？")]),v._v(" "),t("h3",{attrs:{id:"vue3-0变化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue3-0变化"}},[v._v("#")]),v._v(" vue3.0变化")]),v._v(" "),t("h4",{attrs:{id:"一-速度更快"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一-速度更快"}},[v._v("#")]),v._v(" 一. 速度更快")]),v._v(" "),t("ul",[t("li",[v._v("虚拟DOM重新（）\n"),t("ul",[t("li",[v._v("将会有更多的编译时提示来减少运行时的开销，用更有效的代码来创建虚拟节点")])])]),v._v(" "),t("li",[v._v("优化插槽生成（）\n"),t("ul",[t("li",[v._v("父子组件的渲染分开，可以只渲染父组件，不渲染子组件")]),v._v(" "),t("li",[v._v("不需要打补丁的不再打补丁，提高渲染性能")])])]),v._v(" "),t("li",[v._v("静态树提升\n"),t("ul",[t("li",[v._v("不需要打补丁的不再打补丁，提高渲染性能")])])]),v._v(" "),t("li",[v._v("静态属性提升\n"),t("ul",[t("li",[v._v("不需要打补丁的不再打补丁，提高渲染性能")])])]),v._v(" "),t("li",[v._v("基于Proxy的观察者机制\n"),t("ul",[t("li",[v._v("2.0中使用es5的object.defineProperty的getter setter实现的，存在一些局限性， 无法监听响应对象属性的增加删除等，3.0使用代理模式就没有这些局限性")])])])]),v._v(" "),t("h4",{attrs:{id:"二-体积更小"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二-体积更小"}},[v._v("#")]),v._v(" 二. 体积更小")]),v._v(" "),t("ul",[t("li",[v._v("新运行时压缩后大概10kb（相对于2.0 20kb 小了很多）。主要是通过按需引入的方式，减少一些不需要的库，需要什么功能就引入什么功能，没有使用的也就不会打包")])]),v._v(" "),t("h4",{attrs:{id:"三-更易维护"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三-更易维护"}},[v._v("#")]),v._v(" 三. 更易维护")]),v._v(" "),t("ul",[t("li",[v._v("从flow转向type\n"),t("ul",[t("li",[v._v("（flow为facebook的静态类型检查，type为ts。支持ts表现也更好，节省调试bug时间，开发体验更好）")])])]),v._v(" "),t("li",[v._v("解耦，使内容更加模块化\n"),t("ul",[t("li",[v._v("依赖于自己内部包来运行，使得自定义和灵活的同时提供透明性，使开发人员可以真正进入源码")])])]),v._v(" "),t("li",[v._v("编译器重写")])])])}),[],!1,null,null,null);e.default=_.exports}}]);